# 函数整理

#### socket

int socket(int domain,int type,int protocol);

socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);

#### bzero

bzero(ptr,n);

#### htons()

统一成大端序（网络字节序)

htons(hostshort);

#### inet_pton()

int inet_pton(int family,char *src,void *dst)

#### connect()//bind同理

connect(sockfd,(SA*)&sockaddr,len)

#### read()

read(sockfd,buf,len)

#### listen()

listen(sockfd,backlog)//等待队列的最大长度

#### accept()

accept(sockfd,(SA *)&sockaddr,&len)

#### close()

#### shutdown()

shutdown(sockfd,int howto)

#### inet_aton()

inet_aton(chat *src,struct in_addr *addrptr)

#### getsockname()

getsockname(sockfd,(SA *)&addr,&len)

后两个都是value-result参数，可以获取内核分配的地址和端口号，还可以获得协议族，sockfd必须已连接

#### getpeername()

外地

#### wait()

wait(&stat)

#### waitpid()

waitpid(-1,&stat,WNOHANG)

#### select

select(int maxfdl,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout)

#### Fd四个

#### getsockopt()

int getsockopt(sockfd,level,optname,&,&)

#### setsockopt()

int getsockopt(sockfd,level,optname,&,len)

IPPROTO_IP:IP_TTL IP_HDRINCL IP_OPTIONS

IPPROTO_TCP:TCP_MAXSEG

#### sendto()

#### recvfrom()

recvfrom(sockfd,buf,size,flag,&addr,&len)

#### gethostbyname()

gethostbyname(char*)

#### gethostbyaddr()

gethostbyaddr(char * addr,len,family)

#### getservbyname()

(char *,char *)

#### getservbyport()

(int ,char *)

# 程序整理

p5

p13

#### TCP服务器

```
#include <unp.h>

void str_echo(int);

int main(int argc, char** argv){
    int listenfd, connfd;
    pid_t pid;
    socklen_t clen;
    struct sockaddr_in cliaddr, servaddr;

    listenfd = Socket(AF_INET, SOCK_STREAM, 0);

    bzero(&servaddr, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(9748);

    //指定服务端socket的地址为通配地址
    //表示接收来自本机各个网络接口的连接请求
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));
    Listen(listenfd, LISTENQ);

    for( ; ; ){
        clen = sizeof(cliaddr);
        connfd = Accept(listenfd, (SA *) &cliaddr, &clen);
        //接受到来自客户端的请求之后，fork一个进程，在子进程中为客户提供服务
        //父进程则关闭本进程内该已连接描述符（引用计数减1）
        //然后再返回继续accept，可以达到并发的效果
        if( (pid = Fork()) == 0 ){      //子进程执行
            Close(listenfd);
            str_echo(connfd);
            Close(connfd);
            exit(0);
        }
        Close(connfd);                  //父进程执行
    }
}


/**
 * 为客户端提供服务
 * 从客户端接收一个字符串，并将字符串回射回客户端
 */
void str_echo(int connfd){
    ssize_t n;
    char buf[MAXLINE];

again:
    while((n = read(connfd, buf, MAXLINE)) > 0)
        Writen(connfd, buf, n);
    if(n < 0 && errno == EINTR)
        goto again;
    else if(n < 0)
        err_sys("str_echo: read error");
}
```

#### TCP客户端

```
#include <unp.h>

void str_cli(FILE*, int);

int main(int argc, char** argv){
    int sockfd;
    struct sockaddr_in servaddr;

    if(argc != 2)
        err_quit("usage: ./tcpserv01 <IPAddress>");
    sockfd = Socket(AF_INET, SOCK_STREAM, 0);

    bzero(&servaddr, sizeof(servaddr));
    servaddr.sin_port = htons(9748);
    servaddr.sin_family = AF_INET;

    //调用inet_pton函数将用户输入的点分十进制串转化成网络字节序的32为IPv4地址
    Inet_pton(AF_INET, argv[1], &servaddr.sin_addr);

    Connect(sockfd, (SA *) &servaddr, sizeof(servaddr));

    str_cli(stdin, sockfd);
    Close(sockfd);
}

/**
 * 用fgets读取用户的一行输入，发送给服务器，再从服务器接收一行回复并打印到控制台
 */
void str_cli(FILE* fp, int sockfd){
    char sendbuf[MAXLINE], recvline[MAXLINE];
    while(Fgets(sendbuf, MAXLINE, fp) != NULL){
        Writen(sockfd, sendbuf, strlen(sendbuf));
        if(Readline(sockfd, recvline, MAXLINE) == 0)
            err_quit("str_cli: server terminated prematurely");
        Fputs(recvline, stdout);
    }
}
```

#### signal函数原型

```
void (*signal(int signo, void (*func)(int)))(int);

//定义新类型，来化简上面的原型
typedef void Sigfunc(int)

/**
* 为一个信号设置处理函数
* @param signo      信号
* @param func       信号处理函数
* @return           指向信号处理函数
*/
Sigfunc *signal(int signo, Sigfunc *func);
```

#### 处理defunct程序handler func

```
//由于wait不能实现在没有已终止子进程时不要阻塞，所以在下面的循环中不能调用wait，否则可能会阻塞主线程
//经过下面的修改之后，就可以支持一次调用清理多个进程的要求

void sig_chld(int signo){
  pid_t   pid;
  int     stat;
  while( (pid = waitpid(-1, &stat, WNOHANG)) > 0)
    printf("chihld %d terminated\n", pid);
  return;
}
```

#### 处理被中断的accept

```
for( ; ; ){
  clilen = sizeof(cliaddr);
  if( (connfd = accept(listenfd, (SA *) &cliaddr, &clilen)) < 0){
    if(errno == EINTR)
      continue;
    else
      err_sys("accept error");
  }
}
```

#### select应用cli

```
/**
 * 改进后的str_cli函数，可以在服务器停止后马上返回
 */
void str_cli(FILE* fp, int sockfd){
    int     maxfdpl;
    fd_set  rset;
    char    sendline[MAXLINE], recvline[MAXLINE];

    //首先清0
    FD_ZERO(&rset);
    for( ; ; ){
        //在调用select之前，设置监听集，告知select感兴趣的描述符
        FD_SET(fileno(fp), &rset);
        FD_SET(sockfd, &rset);

        //待测试的描述符数应该比我们要监听的最大描述符要大1（因为c语言数组是从0开始计的）
        maxfdpl = max(fileno(fp), sockfd) + 1;

        //一直阻塞，直至上述两个描述符至少其中一个可读（没有指定超时时间，所以会一直等待）
        Select(maxfdpl, &rset, NULL, NULL, NULL);

        if(FD_ISSET(sockfd, &rset)){        //socket 可读
            if(Readline(sockfd, recvline, MAXLINE) == 0)
                err_quit("str_cli: server terminated prematurely");
            Fputs(recvline, stdout);
        }

        if(FD_ISSET(fileno(fp), &rset)){    //用户从控制台输入了数据
            if(Fgets(sendline, MAXLINE, fp) == NULL)
                return;
            Writen(sockfd, sendline, strlen(sendline));
        }
    }
}
```

#### UDP服务器程序

```
#include <unp.h>

void dg_echo(int sockfd, SA *cliaddr, socklen_t clilen);

int main(int argc, char **argv){
    int sockfd;
    struct sockaddr_in servaddr, cliaddr;

    //第二个参数指定为SOCK_DGRAM，标识创建一个UDP套接字
    sockfd = Socket(AF_INET, SOCK_DGRAM, 0);

    bzero(&servaddr, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(9748);
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    //为套接字绑定众所周知的端口号，以及指定接收哪些网络接口的请求
    Bind(sockfd, (SA *) &servaddr, sizeof(servaddr));

    dg_echo(sockfd, (SA *) &cliaddr, sizeof(cliaddr));
}

void dg_echo(int sockfd, SA *cliaddr, socklen_t clilen){
    int n;
    socklen_t len;
    char mesg[MAXLINE];

    for( ; ; ){
        len = clilen;
        //接收客户号段发送的消息
        n = Recvfrom(sockfd, mesg, MAXLINE, 0, cliaddr, &len);

        //回射
        Sendto(sockfd, mesg, n, 0, cliaddr, len);
    }
}
```

#### UDP客户端程序

```
#include <unp.h>

void dg_cli_my(FILE *fp, int sockfd, SA *servaddr, socklen_t len);

int main(int argc, char **argv){
    int sockfd;
    struct sockaddr_in servaddr;

    if(argc != 2)
        err_quit("usage: ./udpcli01 <IPAddress>\n");

    //创建一个UDP套接字
    sockfd = Socket(AF_INET, SOCK_DGRAM, 0);

    bzero(&servaddr, sizeof(servaddr));

    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(9748);

    Inet_pton(AF_INET, argv[1], &servaddr.sin_addr);

    dg_cli_my(stdin, sockfd, (SA *) &servaddr, sizeof(servaddr));
}

void dg_cli_my(FILE* fp, int sockfd, SA *servaddr, socklen_t len){
    int n;
    char sendline[MAXLINE], recvline[MAXLINE];

    //从控制台接收用户输入，并发送给服务器
    //接着接收服务器回射的消息，并输出到控制台
    while( (Fgets(sendline, MAXLINE, fp)) != NULL){
        Sendto(sockfd, sendline, strlen(sendline), 0, servaddr, len);
        n = Recvfrom(sockfd, recvline, MAXLINE, 0, NULL, NULL);
        recvline[n] = 0;
        Fputs(recvline, stdout);
    }

}
```

#### ping

![img](https://sunnyqjm.github.io/img/unp_44.png)

#### 大小端

```
#include"stdio.h"
int main()
{
union un
{
	short a;
	char b[sizeof(short)];
}u;
u.a=0x0102;
if(u.b[0]==1&&u.b[1]==2)
	printf("big endian");
else if(u.b[0]==2&&u.b[1]==1)
	printf("small endian");
else
	printf("unknown");
return 0;
}
```

#### daytime client

```
#include <unp.h>

int main(int argc, char** argv){
    /*sockfd 套接字描述符，客户端通过该描述符与服务器进行通信（它指示一个与服务器的连接）*/
    int sockfd, n;
    char recvline[MAXLINE + 1];         /*接收缓存*/

    /*服务器地址，用来保存服务器的地址信息（该结构体专门保存IPV4地址），包括ip和端口*/
    struct sockaddr_in servaddr;

    /*如果输入参数不够，则报错并退出*/
    if(argc != 2)
        err_quit("usage: daytimecli <IPAddress>");

    /*通过socket函数创建一个套接字，创建失败则退出*/
    if( (sockfd = socket(AF_INET, SOCK_STREAM, 0) ) < 0)
        err_sys("socket error");

    /*清0*/
    bzero(&servaddr, sizeof(servaddr));
    servaddr.sin_family = AF_INET;      /*指定协议族为网际协议族*/
    servaddr.sin_port = htons(13);      /*指定端口为13*/

    /*将用户从命令行输入的IP存到servaddr中，如果用户输入的格式不正确*/
    /*则该函数会返回小于0的错误信息，此时退出应用程序*/
    if(inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0)
        err_quit("inet_pton error for %s", argv[1]);

    /*连接到servaddr指向的服务器，连接失败则退出*/
    if(connect(sockfd, (SA *)&servaddr, sizeof(servaddr)) < 0)
        err_sys("connect error");

    /*读取服务器发回的信息*/
    while( (n = read(sockfd, recvline, MAXLINE)) > 0 ){
        recvline[n] = 0;

        /*输出到控制台*/
        if(fputs(recvline, stdout) == EOF)
            err_sys("fputs error");
    }

    if(n < 0)
        err_sys("read error");
    exit(0);
}

```

#### daytime server

```
#include <unp.h>
#include <time.h>

int main(int argc, int argv){
    int listenfd, connfd;
    struct sockaddr_in servaddr;
    char buff[MAXLINE];
    time_t ticks;

    //调用包裹函数，创建一个socket
    listenfd = Socket(AF_INET, SOCK_STREAM, 0);

    bzero(&servaddr, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(13);

    //指定socket的地址为INADDR_ANY，标识监听来自所有地址的请求
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    //将socket绑定到指定的端口，只在指定的端口监听来自客户端的请求
    Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));

    //调用Lisen可将socket转换成一个监听套接字，监听套接字可用于监听其他客户端的请求
    Listen(listenfd, LISTENQ);

    for( ; ; ){
        //accpet函数是一个阻塞函数，死等一个连接请求。
        //当监听到一个请求，就返回一个已连接描述符（该描述符用于与新连接的那个客户端通信）
        connfd = Accept(listenfd, (SA *) NULL, NULL);

        //获取当前系统的时间
        ticks = time(NULL);

        //将当前时间输出到buff数组中
        snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&ticks));

        //将buff中的数据发给客户端
        Write(connfd, buff, strlen(buff));

        //关闭socket连接
        Close(connfd);
    }
}
```

